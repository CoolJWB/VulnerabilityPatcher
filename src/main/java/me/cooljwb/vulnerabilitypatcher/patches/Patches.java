package me.cooljwb.vulnerabilitypatcher.patches;

import me.cooljwb.vulnerabilitypatcher.VulnerabilityPatcher;
import me.cooljwb.vulnerabilitypatcher.SMG;
import net.md_5.bungee.api.ChatColor;
import net.md_5.bungee.api.chat.*;
import net.minecraft.server.v1_13_R2.AttributeModifier;
import net.minecraft.server.v1_13_R2.ChatMessageException;
import net.minecraft.server.v1_13_R2.NBTTagCompound;
import net.minecraft.server.v1_13_R2.NBTTagList;

import org.apache.commons.lang.builder.ReflectionToStringBuilder;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.attribute.Attribute;
import org.bukkit.command.CommandSender;
import org.bukkit.craftbukkit.v1_13_R2.entity.CraftEntity;
import org.bukkit.craftbukkit.v1_13_R2.inventory.CraftItemStack;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.Listener;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.scheduler.BukkitScheduler;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * Copyright 2019 CoolJWB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author CoolJWB
 */

public class Patches implements Listener {

    public static VulnerabilityPatcher main;
    public static String pluginName, pluginVersion;
    public static boolean notify, devmode;
    public List<String> listeners;

    private Death_Items death_items;
    private Disconnect_Items disconnect_items;
    private Crash_Items crash_items;
    private Rouge_Entity rouge_entity;

    private Logger log = Logger.getLogger("Minecraft");
    private HashMap<String, Float> active_attributes = new HashMap<>(); 

    public Patches() {}
    public Patches(VulnerabilityPatcher main) {
        this.main = main;
        listeners = main.getConfig().getStringList("Patches");
        runnable();
    }

    public void initialize() {
        this.pluginName = main.getName();
        this.pluginVersion = main.getDescription().getVersion();
        this.notify = main.getConfig().getBoolean("Notify.Enabled");
        this.devmode = main.getConfig().getBoolean("DevMode");

        this.death_items = main.death_items;
        this.disconnect_items = main.disconnect_items;
        this.crash_items = main.crash_items;
    }

    public void runnable() {
        BukkitScheduler scheduler = Bukkit.getServer().getScheduler();
        scheduler.scheduleSyncRepeatingTask(main, new Runnable() {
            @Override
            public void run() {
                for(Player player : Bukkit.getOnlinePlayers()) {
                    for(ItemStack item : player.getInventory()) {

                    	if(listeners.contains("DisconnectItems") && itemInVisibleSlot(player.getInventory(), item)) {
                    		NBTTagList item_attributes = getNBTAttributeList(item);
                    		
                    		if(item_attributes != null) {
                    			for(int a = 0; a <= item_attributes.size(); a++) {
                    				NBTTagCompound attribute = item_attributes.getCompound(a);
                    				
                    				if(attribute != null && !attribute.isEmpty()) {
	                    				String attr_name = attribute.getString("AttributeName").toLowerCase();
	                    				float attr_amount = attribute.getFloat("Amount");
	                    				
	                       				if((active_attributes.containsKey("generic.movementspeed") && attr_name.equalsIgnoreCase("generic.movementspeed")) && (Float.isFinite(active_attributes.get("generic.movementspeed")) || Float.isInfinite(active_attributes.get("generic.movementspeed")) || active_attributes.get("generic.movementspeed") == Float.NEGATIVE_INFINITY) && (Float.isFinite(attr_amount) || Float.isInfinite(attr_amount) || attr_amount == Float.NEGATIVE_INFINITY)) {
	                            			msg(player, SMG.ITEMS.msg);
	                       				    clearItemMeta(item);
	                            		}

	                    				active_attributes.put(attr_name, attr_amount);
                    				}
                    			}
                    		}
                    	}
                    	
                        for(String listener : listeners) {
                            switch(listener) {
                                case "DeathItems":
                                    if(death_items.isDeathItem(item) || death_items.containsDeathItem(item)) {
                                        clearItemMeta(item);
                                        notifyViolation(player, "acquire", "death item", player.getLocation());
                                        msg(player, SMG.ITEMS.msg);
                                    } break;

                                case "DisconnectItems":
                                    if(disconnect_items.isDisconnectItem(item) || disconnect_items.containsDisconnectItem(item)) {
                                        clearItemMeta(item);
                                        notifyViolation(player, "acquire", "disconnect item", player.getLocation());
                                        msg(player, SMG.ITEMS.msg);
                                    } break;

                                case "CrashItems":
                                    if(crash_items.isCrashItem(item) || crash_items.containsCrashItem(item)) {
                                        clearItemMeta(item);
                                        notifyViolation(player.getName(), "acquire", "crash item", player.getLocation());
                                        msg(player, SMG.ITEMS.msg);
                                    } break;
                            }
                        }
                    }
                    active_attributes.clear();
                }
            }
        }, 0L, 0);
    }

    public void msg(Player player, String msg) {
        player.sendMessage(msg);
    }

    public void msg(CommandSender sender, String msg) {
        sender.sendMessage(msg);
    }

    public void notify(String msg) {
        if(notify) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission(main.getConfig().getString("Notify.Permission")))
                    player.sendMessage(msg);
            }
        }
    }

    public void notify(BaseComponent msg) {
        if(notify) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission(main.getConfig().getString("Notify.Permission")))
                    player.spigot().sendMessage(msg);
            }
        }
    }

    public void notifyViolation(Player player, String violation_form, String violation_name, Location loc) {
        if(player != null) {
            TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, player.getName(), violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

            notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
            notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
            notification.setColor(ChatColor.RED);

            notify(notification);
        }

        else {
            TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, "Unknown", violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

            notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
            notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
            notification.setColor(ChatColor.RED);

            notify(notification);
        }
    }


    public void notifyViolation(String violator, String violation_form, String violation_name, Location loc) {
        TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, violator, violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

        notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
        notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
        notification.setColor(ChatColor.RED);

        notify(notification);
    }

    public void debug(Event event) {
        try {
            if (devmode)
                log.log(Level.INFO, String.format("[%s] Event in %s: %s", pluginName, getClass().getName(), ReflectionToStringBuilder.toString(event)));
        } catch(ChatMessageException e) {
            log.log(Level.INFO, String.format("[%s] Could not debug event in %s.", pluginName, getClass().getName()));
        }
    }

    public void clearItemMeta(ItemStack item) {
        item.setItemMeta(null);
    }

    public void clearItemMeta(ItemStack[] items) {
        for(ItemStack item : items) {
            if(item != null)
                item.setItemMeta(null);
        }
    }

    public NBTTagCompound getNBTItemTag(ItemStack item) {
    	if(item != null) {
    		net.minecraft.server.v1_13_R2.ItemStack nmsItemStack = CraftItemStack.asNMSCopy(item);
    		if(nmsItemStack != null)
    			return nmsItemStack.getTag();
    	}
    	return null;
    }
    
    public NBTTagCompound getEntityNMS(Entity entity) {
        net.minecraft.server.v1_13_R2.Entity nmsEntity = ((CraftEntity)entity).getHandle();
        NBTTagCompound tag = new NBTTagCompound();
        nmsEntity.save(tag);
        return tag;
    }
    
    public NBTTagList getNBTAttributeList(ItemStack item) {
    	NBTTagCompound itemtag = getNBTItemTag(item);
    	
    	if(item != null && itemtag != null && itemtag.hasKey("AttributeModifiers"))
    		return getNBTItemTag(item).getList("AttributeModifiers", 10);
		return null;
    }
    
    public String itemToString(ItemStack item) {
        if(item != null) {
            net.minecraft.server.v1_13_R2.ItemStack nmsItemStack = CraftItemStack.asNMSCopy(item);

            if(nmsItemStack.hasTag())
                return nmsItemStack.getTag().toString();
        }
        return "";
    }
    
    public boolean itemInVisibleSlot(PlayerInventory inv, ItemStack item) {
        ItemStack mainhand = inv.getItemInMainHand();
        ItemStack offhand = inv.getItemInOffHand();

    	if(item != null && inv != null && mainhand != null && offhand != null) {
    	    if(inv.getItemInMainHand().isSimilar(item) || inv.getItemInOffHand().isSimilar(item))
    	        return true;

    	    else {
    	        for(ItemStack items : inv.getArmorContents()) {
    	            if(items != null && items.isSimilar(item))
    	                return true;
                }
            }
    	}
    	return false;
    }
}
