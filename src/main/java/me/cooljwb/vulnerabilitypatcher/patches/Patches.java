package me.cooljwb.vulnerabilitypatcher.patches;

import me.cooljwb.vulnerabilitypatcher.SMG;
import me.cooljwb.vulnerabilitypatcher.VulnerabilityPatcher;
import me.cooljwb.vulnerabilitypatcher.modifiers.NBTModifier;
import net.md_5.bungee.api.ChatColor;
import net.md_5.bungee.api.chat.*;
//import net.minecraft.server.v1_14_R1.ChatMessageException;
import org.apache.commons.lang.builder.ReflectionToStringBuilder;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.scheduler.BukkitScheduler;

import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * Copyright 2019 CoolJWB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author CoolJWB
 */

public class Patches extends NBTModifier implements Listener {

    // TODO: Add violation runnable that checks if it should send a violation each second for players that tries to use exploits.

    public static VulnerabilityPatcher main;
    public static String pluginName, pluginVersion;
    public static boolean notify, devmode;
    public List<String> listeners;

    private Death_Items death_items;
    private Disconnect_Items disconnect_items;
    private Crash_Items crash_items;
    private Rouge_Entity rouge_entity;

    private Logger log = Logger.getLogger("Minecraft");
    private HashMap<String, Float> active_attributes = new HashMap<>();

    protected byte mode = 0;

    public Patches() {}
    public Patches(VulnerabilityPatcher main) {
        Patches.main = main;
        listeners = main.getConfig().getStringList("Patches");
        runnable();
    }

    public void initialize() {
        pluginName = main.getName();
        pluginVersion = main.getDescription().getVersion();
        notify = main.getConfig().getBoolean("Notify.Enabled");
        devmode = main.getConfig().getBoolean("DevMode");
        this.mode = mode(main.getConfig().getString("SecurityMode"));

        this.death_items = main.death_items;
        this.disconnect_items = main.disconnect_items;
        this.crash_items = main.crash_items;
    }

    public void runnable() {
        BukkitScheduler scheduler = Bukkit.getServer().getScheduler();
        scheduler.scheduleSyncRepeatingTask(main, new Runnable() {
            @Override
            public void run() {
                for(Player player : Bukkit.getOnlinePlayers()) {
                    if(player.getLocation().getY() <= -29999999) // Fixes invalid movement disconnection.
                        player.getLocation().setY(-29999999);
                    else if(player.getLocation().getY() >= 29999999) // Fixes invalid movement disconnection.
                        player.getLocation().setY(29999999);

                    for(ItemStack item : player.getInventory()) {
                    	/*if(listeners.contains("DisconnectItems") && itemInVisibleSlot(player.getInventory(), item)) {

                    		NBTTagList item_attributes = getNBTAttributeList(item);
                    		
                    		if(item_attributes != null) {
                    			for(int a = 0; a <= item_attributes.size(); a++) {
                    				NBTTagCompound attribute = item_attributes.getCompound(a);
                    				
                    				if(attribute != null && !attribute.isEmpty()) {
	                    				String attr_name = attribute.getString("AttributeName").toLowerCase();
	                    				float attr_amount = attribute.getFloat("Amount");
	                    				
	                       				if((active_attributes.containsKey("generic.movementspeed") && attr_name.equalsIgnoreCase("generic.movementspeed")) && (Float.isFinite(active_attributes.get("generic.movementspeed")) || Float.isInfinite(active_attributes.get("generic.movementspeed")) || active_attributes.get("generic.movementspeed") == Float.NEGATIVE_INFINITY) && (Float.isFinite(attr_amount) || Float.isInfinite(attr_amount) || attr_amount == Float.NEGATIVE_INFINITY)) {
	                            			msg(player, SMG.ITEMS.msg);
	                       				    clearItemMeta(item);
	                            		}

	                    				active_attributes.put(attr_name, attr_amount);
                    				}
                    			}
                    		}
                    	}*/
                    	
                        for(String listener : listeners) {
                            switch(listener) {
                                case "DeathItems":
                                    if(death_items.isDeathItem(item)) { // Removed containsDeathItem cause it's useless to check for death items in a container when it's checked event wise.
                                        clearItemMeta(item);
                                        notifyViolation(player, "acquire", "death item", player.getLocation());
                                        msg(player, SMG.ITEMS.msg);
                                    } break;

                                case "DisconnectItems":
                                    if(disconnect_items.isDisconnectItem(item) || disconnect_items.containsDisconnectItem(item)) {
                                        clearItemMeta(item);
                                        notifyViolation(player, "acquire", "disconnect item", player.getLocation());
                                        msg(player, SMG.ITEMS.msg);
                                    } break;

                                case "CrashItems":
                                    if(crash_items.isCrashItem(item) || crash_items.containsCrashItem(item)) {
                                        clearItemMeta(item);
                                        notifyViolation(player.getName(), "acquire", "crash item", player.getLocation());
                                        msg(player, SMG.ITEMS.msg);
                                    } break;
                            }
                        }
                    }
                    active_attributes.clear();
                }

                for(World world : Bukkit.getWorlds()) {
                    for(Entity entity : world.getEntities()) {
                        if(entity.getName().equalsIgnoreCase("Minecart with Spawner")) {
                            entity.remove();
                        }
                    }
                } // Remove Spawner Minecarts.
            }
        }, 20L, 0); // Made the delay 20 ticks cause it's easier on the server.
    }

    void msg(Player player, String msg) {
        player.sendMessage(msg);
    }
    protected void msg(CommandSender sender, String msg) {
        sender.sendMessage(msg);
    }

    public void notify(String msg) {
        if(notify) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission(main.getConfig().getString("Notify.Permission")))
                    player.sendMessage(msg);
            }
        }
    }
    private void notify(BaseComponent msg) {
        if(notify) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission(main.getConfig().getString("Notify.Permission")))
                    player.spigot().sendMessage(msg);
            }
        }
    }
    void notifyViolation(Player player, String violation_form, String violation_name, Location loc) {
        if(player != null) {
            TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, player.getName(), violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

            notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
            notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
            notification.setColor(ChatColor.RED);

            notify(notification);
        }

        else {
            TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, "Unknown", violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

            notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
            notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
            notification.setColor(ChatColor.RED);

            notify(notification);
        }
    }
    void notifyViolation(String violator, String violation_form, String violation_name, Location loc) {
        TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, violator, violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

        notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
        notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
        notification.setColor(ChatColor.RED);

        notify(notification);
    }

    public void log(Level level, String message) {
        log.log(level, String.format("[%s] %s", VulnerabilityPatcher.pluginName, message));
    }
    public void debug(Event event) {
        if (devmode)
            log(Level.INFO, String.format("Event in %s: %s", getClass().getName(), ReflectionToStringBuilder.toString(event)));
    }
    void fired_countermeasure(String reason) {
        if (devmode)
            log(Level.INFO, String.format("Fired countermeasure in %s reason: %s", getClass().getName(), reason));
    }
    private byte mode(String mode) {
        switch(mode) {
            case "EASY":
                return 0;
            case "MEDIUM":
                return 1;
            case "STRICT":
                return 2;
            default:
                return 0;
        }
    }

    void clearItemMeta(ItemStack item) {
        item.setItemMeta(null);
    }
    void clearItemMeta(ItemStack[] items) {
        for(ItemStack item : items) {
            if(item != null)
                item.setItemMeta(null);
        }
    }

    public boolean itemInVisibleSlot(PlayerInventory inv, ItemStack item) {
        ItemStack mainhand = inv.getItemInMainHand();
        ItemStack offhand = inv.getItemInOffHand();

    	if(item != null && inv != null && mainhand != null && offhand != null) {
    	    if(inv.getItemInMainHand().isSimilar(item) || inv.getItemInOffHand().isSimilar(item))
    	        return true;

    	    else {
    	        for(ItemStack items : inv.getArmorContents()) {
    	            if(items != null && items.isSimilar(item))
    	                return true;
                }
            }
    	}
    	return false;
    }
}
